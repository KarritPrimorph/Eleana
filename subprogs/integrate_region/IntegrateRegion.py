#!/usr/bin/python3

# IMPORT MODULES NEEDED
from scipy.integrate import cumulative_trapezoid, trapezoid

# General setting of the application. Here is an example
# File/Path/Class settings

'''
##################################
#     SUBPROG SETTINGS           #
##################################'''

# General
SUBPROG_FOLDER = 'integrate_region'     # <--- SUBFOLDER IN SUBPROGS CONTAINING THIS FILE
GUI_FILE = 'IntegrateRegionui.py'       # <--- PYTHON FILE GENERATED BY PYGUBU-DESIGNER CONTAINING GUI
GUI_CLASS = 'IntegrateRegionUI'         # <--- CLASS NAME IN GUI_FILE THAT BUILDS THE WINDOW

# ---
TITLE = 'Integrate region'              # <--- TITLE OF THE WINDOW
ON_TOP = True                           # <--- IF TRUE THE WINDOW WILL BE ALWAYS ON TOP
DATA_LABEL = 'data_label'               # <--- ID OF THE LABEL WIDGET WHERE NAME OF CURRENTLY SELECTED DATA WILL APPEAR.
                                        #      THE LABEL WIDGET OF THE SAME ID NAME MUST EXIST IN THE GUI. IF NOT USED SET THIS TO NONE

NAME_SUFFIX = '_INTEGRAL'                    # <--- DEFINES THE SUFFIX THAT WILL BE ADDED TO NAME OF PROCESSED DATA
AUTO_CALCULATE = False                   # <--- DEFINES IF CALCULATION IS AUTOMATICALLY PERFORMED UPON DATA CHANGE IN GUI

# Data settings
#REGIONS_FROM = 'scale'                  # <--- DEFINES IF DATA WILL BE EXTRACTED:
REGIONS_FROM = 'selection'              #       'none' - DO NOT EXTRACT

USE_SECOND = False                      # <--- IF TRUE THEN FIRST AND SECOND DATA WILL BE AVAILABLE FOR CALCULATIONS
STACK_SEP = True                        # <--- IF TRUE THEN EACH DATA IN A STACK WILL BE CALCULATED SEPARATELY
                                        #      WHEN FALSE THEN YOU MUST CREATE A METHOD THAT CALCS OF THE WHOLE STACK
#RESULT_CREATE = 'add'                  # <--- DETEMINES IF PROCESSED DATA SHOULD BE ADDED TO RESULT_DATASET
RESULT_CREATE = 'replace'               #     'ADD' OR 'REPLACE' IS SELF EXPLANATORY
                                        #      ANY OTHER VALUES MEANS NOT RESULT CREATION

# Report settings
REPORT_CREATE = True                           # <--- IF TRUE THEN REPORT WILL BE CREATED AFTER CALCULATIONS
REPORT_SKIP_FOR_STK = True
REPORT_WINDOW_TITLE = 'Results of integration'
REPORT_HEADERS = ['Nr',
                  'Name',
                  'Parameter values \n for consecutive data in stack',
                  'Double integration',
                  'Integral Value',
                  'Points No.'] # <--- Define names of columns in the Report

REPORT_DEFAULT_X = 0                    # <--- INDEX IN REPORT_HEADERS USED TO SET NAME OF COLUMN THAT IS USED AS DEFAULT X IN THE REPORT
REPORT_DEFAULT_Y = 4                    # <--- INDEX IN REPORT_HEADERS USED TO SET NAME OF COLUMN THAT IS USED AS DEFAULT Y IN THE REPORT
REPORT_NAME = "Results of integration"
REPORT_NAME_X =  'Data Number'          # <--- NAME OF X AXIS IN THE REPORT
REPORT_NAME_Y =  'Integral Value'       # <--- NAME OF Y AXIS IN THE REPORT
REPORT_UNIT_X = ''                      # <--- NAME OF X UNIT IN THE CREATED REPORT
REPORT_UNIT_Y = ''                      # <--- NAME OF Y UNIT IN THE CREATED REPORT
REPORT_TO_GROUP = 'RESULT Integrate'              # <--- DEFAULT GROUP NAME TO WHICH REPORT WILL BE ADDED

# Cursors on graph
CURSOR_CHANGING = False                 # <--- IF TRUE THEN SELECTION OF CURSOR MODE IN MAN GUI IS DISABLED
CURSOR_TYPE = 'Range select'            # <--- USE CURSORS: 'None', 'Continuous read XY', 'Selection of points with labels'
                                        #       'Selection of points', 'Numbered selections', 'Free select', 'Crosshair', 'Range select'
CURSOR_LIMIT = 0                        # <--- SET THE MAXIMUM NUMBER OF CURSORS THAT CAN BE SELECTED. FOR NO LIMIT SET 0
CURSOR_CLEAR_ON_START =  False           # <--- CLEAR CURSOR ON START THE WINDOW
CURSOR_REQUIRED = 0                     # <--- MINIMUM NUMBER OF CURSORS TO PROCESS THE CALCULATIONS
                                        #      SET TO 0 FOR NO CHECKING
CURSOR_REQ_TEXT = \
    ''                                  # <--- TEXT TO DISPLAY IF NR OF CURSORS IS LESS THAN REQUIRED
                                        #    LEAVE EMPTY IF YOU DO NOT WANT TO SHOW THE ERROR
CURSOR_OUTSIDE_X = False                 # <--- CHECK IF ALL CURSORS ARE BETWEEN Xmin Xmax FOR SELF>DATA_FOR_CALCULATIONS
CURSOR_OUTSIDE_Y = False
CURSOR_OUTSIDE_TEXT = \
                'One or more selected points are outside the (x, y) range of data.'


'''
##################################
#    END OF SUBPROG SETTINGS     #
#  DO NOT MODIFY LINES BELOW     #
##################################'''

cmd_to_import = GUI_FILE[:-3] + ' import ' + GUI_CLASS + ' as WindowGUI'
if __name__ == "__main__":
    cmd_to_import = 'from ' + cmd_to_import
    cmd_to_import = cmd_to_import + '\nfrom assets.Eleana import Eleana'
else:
    cmd_to_import = 'from ' + SUBPROG_FOLDER + '.' + cmd_to_import
exec(cmd_to_import)
from subprogs.general_methods.SubprogMethods2 import SubMethods_02

class IntegrateRegion(SubMethods_02, WindowGUI):
    ''' THIS IS STANDARD CONSTRUCTOR THAT SHOULD NOT BE MODIFIED '''

    def __init__(self, app=None, which='first', commandline=False):  # |
        if app and not commandline:  # |
            # Initialize window if app is defined and not commandline                               #|
            WindowGUI.__init__(self, app.mainwindow)  # |
        # Create settings for the subprog                                                           #|
        self.subprog_settings = {'title': TITLE, 'on_top': ON_TOP, 'data_label': DATA_LABEL,
                                 'name_suffix': NAME_SUFFIX, 'auto_calculate': AUTO_CALCULATE,
                                 'result': RESULT_CREATE
                                 }  # |
        self.regions = {'from': REGIONS_FROM}  # |
        self.report = self.report = {'nr': 1,
                       'create': REPORT_CREATE,
                       'headers': REPORT_HEADERS,
                       'rows': [],
                       'x_name': REPORT_NAME_X,
                       'y_name': REPORT_NAME_Y,
                       'default_x': REPORT_HEADERS[REPORT_DEFAULT_X],
                       'default_y': REPORT_HEADERS[REPORT_DEFAULT_Y],
                       'x_unit': REPORT_UNIT_X,
                       'y_unit': REPORT_UNIT_Y,
                       'to_group': REPORT_TO_GROUP,
                       'report_skip_for_stk':REPORT_SKIP_FOR_STK,
                       'report_window_title':REPORT_WINDOW_TITLE,
                       'report_name':REPORT_NAME
                       }  # |
        self.subprog_cursor = {'type': CURSOR_TYPE, 'changing': CURSOR_CHANGING, 'limit': CURSOR_LIMIT,
                               'clear_on_start': CURSOR_CLEAR_ON_START, 'cursor_required': CURSOR_REQUIRED,
                               'cursor_req_text': CURSOR_REQ_TEXT, 'cursor_outside_x': CURSOR_OUTSIDE_X, 'cursor_outside_y': CURSOR_OUTSIDE_Y,
                               'cursor_outside_text': CURSOR_OUTSIDE_TEXT}
        # Use second data
        self.use_second = USE_SECOND
        # Treat each data in stack separately
        self.stack_sep = STACK_SEP  # |
        SubMethods_02.__init__(self, app=app, which=which, commandline=commandline)  # |

    # DEFINE YOUR CUSTOM METHODS FOR THIS ROUTINE
    # ----------------------------------------------
    def configure_window(self):
        # HERE DEFINE ADDITIONAL WINDOW CONFIGURATION
        #self.mainwindow =

        # HERE DEFINE YOUR REFERENCES TO WIDGETS
        self.check_double_integration = self.builder.get_object('check_double', self.mainwindow)

        # AND CONFIGURE CUSTOM WIDGETS
        self.field_value = self.builder.get_object('field_value', self.mainwindow)


    def set_double_integration(self):
        pass

    def calculate_stack(self, commandline = False):
        ''' If STACK_SEP is False it means that data in stack should
            not be treated as separate data but are calculated as whole
            '''
        # AVAILABLE DATA. REMOVE UNNECESSARY
        # EACH X,Y,Z IS NP.ARRAY
        # X, Z is 1D, Y is 2D
        # -----------------------------------------
        x1 = self.data_for_calculations[0]['x']
        y1 = self.data_for_calculations[0]['y']
        z1 = self.data_for_calculations[0]['z']
        name1 = self.data_for_calculations[0]['name']
        stk_value1 = self.data_for_calculations[0]['stk_value']
        complex1 = self.data_for_calculations[0]['complex']
        type1 = self.data_for_calculations[0]['type']
        origin1 = self.data_for_calculations[0]['origin']
        comment1 = self.data_for_calculations[0]['comment']
        parameters1 = self.data_for_calculations[0]['parameters']
        if self.use_second:
            x2 = self.data_for_calculations[1]['x']
            y2 = self.data_for_calculations[1]['y']
            z2 = self.data_for_calculations[1]['z']
            name2 = self.data_for_calculations[1]['name']
            stk_value2 = self.data_for_calculations[1]['stk_value']
            complex2 = self.data_for_calculations[1]['complex']
            type2 = self.data_for_calculations[1]['type']
            origin2 = self.data_for_calculations[1]['origin']
            comment2 = self.data_for_calculations[1]['comment']
            parameters2 = self.data_for_calculations[1]['parameters']
        # ------------------------------------------


        row_to_report = [self.consecutive_number, name1, '', '', '', '']
        return row_to_report

    def calculate(self, commandline = False):
        ''' The algorithm for calculations on single x,y,z data.

        Usage:
            x1, y1, z1: contain the prepared x, y, z data for calculations
            x2, y2, z2: contain the reference data to use for example to subtract from data1
        After calculation put calculated data to:
            x1, y1 and z1 etc.
            result: the value of resulted calculations
        '''

        # AVAILABLE DATA. REMOVE UNNECESSARY
        # EACH X,Y,Z IS NP.ARRAY OF ONE DIMENSION
        # -----------------------------------------
        x1 = self.data_for_calculations[0]['x']
        y1 = self.data_for_calculations[0]['y']
        z1 = self.data_for_calculations[0]['z']
        name1 = self.data_for_calculations[0]['name']
        stk_value1 = self.data_for_calculations[0]['stk_value']
        complex1 = self.data_for_calculations[0]['complex']
        type1 = self.data_for_calculations[0]['type']
        origin1 = self.data_for_calculations[0]['origin']
        comment1 = self.data_for_calculations[0]['comment']
        parameters1 = self.data_for_calculations[0]['parameters']
        if self.use_second:
            x2 = self.data_for_calculations[1]['x']
            y2 = self.data_for_calculations[1]['y']
            z2 = self.data_for_calculations[1]['z']
            name2 = self.data_for_calculations[1]['name']
            stk_value2 = self.data_for_calculations[1]['stk_value']
            complex2 = self.data_for_calculations[1]['complex']
            type2 = self.data_for_calculations[1]['type']
            origin2 = self.data_for_calculations[1]['origin']
            comment2 = self.data_for_calculations[1]['comment']
            parameters2 = self.data_for_calculations[1]['parameters']
        # ------------------------------------------

        if self.app:
            # Application is running and parameters are taken from GUI
            double = self.check_double_integration.get()
        y_cal = cumulative_trapezoid(y1, x1, initial=0)
        integral = trapezoid(y1,x1)
        if double:
            y_cal2 = cumulative_trapezoid(y_cal, x1, initial=0)
            integral = trapezoid(y_cal, x1)
            y_cal = y_cal2
        result = integral # <--- Put the result value to 'result' variable
        self.data_for_calculations[0]['y'] = y_cal

        double = self.check_double_integration.get()
        row_to_report = [self.consecutive_number, name1, stk_value1, double, result, str(len(y1))]

        # Update Window Widgets
        if self.app and not self.commandline:
            self.field_value.delete(0, 'end')
            self.field_value.insert(0, str(result)) # <--- Put 'result' to the widget
        return row_to_report

if __name__ == "__main__":

    pass
