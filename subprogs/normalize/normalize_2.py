#!/usr/bin/python3
# IMPORT MODULES NEEDED
# -- Here is an example --
import numpy as np

from subprogs.integrate_region.IntegrateRegion import RESULT_CREATE
from CTkSpinbox import CTkSpinbox

# General setting of the application. Here is an example
# File/Path/Class settings

SUBPROG_FOLDER = 'normalize'            # <--- SUBFOLDER IN SUBPROGS CONTAINING THIS FILE
GUI_FILE = 'Normalizeui.py'          # <--- PYTHON FILE GENERATED BY PYGUBU-DESIGNER CONTAINING GUI
GUI_CLASS = 'NormalizeUI'            # <--- CLASS NAME IN GUI_FILE THAT BUILDS THE WINDOW

# Window settings
TITLE = 'Normalize amplitude'         # <--- TITLE OF THE WINDOW
ON_TOP = True                           # <--- IF TRUE THE WINDOW WILL BE ALWAYS ON TOP
DATA_LABEL = None               # <--- ID OF THE LABEL WIDGET WHERE NAME OF CURRENTLY SELECTED DATA WILL APPEAR.
                                        #      THE LABEL WIDGET OF THE SAME ID NAME MUST EXIST IN THE GUI. IF NOT USED SET THIS TO NONE
NAME_SUFFIX = '_NORM'                        # <--- DEFINES THE SUFFIX THAT WILL BE ADDED TO NAME OF PROCESSED DATA
AUTO_CALCULATE = False                  # <--- DEFINES IF CALCULATION IS AUTOMATICALLY PERFORMED UPON DATA CHANGE IN GUI

# Data settings
REGIONS_FROM = 'none'
#REGIONS_FROM = 'scale'                  # <--- DEFINES IF DATA WILL BE EXTRACTED:
#REGIONS_FROM = 'selection'             # 'none' - DO NOT EXTRACT
                                        # 'scale' - EXTRACT DATA BETWEEN X MIN X MAX
                                        # 'sel' - EXTRACT DATA FROM SELECTED RANGE

USE_SECOND = False                      # <--- IF TRUE THEN FIRST AND SECOND DATA WILL BE AVAILABLE FOR CALCULATIONS
STACK_SEP = False                       # <--- IF TRUE THEN EACH DATA IN A STACK WILL BE CALCULATED SEPARATELY
                                        #      WHEN FALSE THEN YOU MUST CREATE A METHOD THAT CALCS OF THE WHOLE STACK
#RESULT_CREATE = ''
#RESULT_CREATE = 'add'                  # <--- DETEMINES IF PROCESSED DATA SHOULD BE ADDED TO RESULT_DATASET
RESULT_CREATE = 'replace'              #      'ADD' OR 'REPLACE' IS SELF EXPLANATORY
                                        #      ANY OTHER VALUES MEANS NOT RESULT CREATION

# Report settings
REPORT_CREATE = False                   # <--- IF TRUE THEN REPORT WILL BE CREATED AFTER CALCULATIONS
REPORT_SKIP_FOR_STK = True              # <--- IF TRUE THEN REPORT WILL NOT BE SHOWN EVEN AFTER PROCESSING OF 2D STACK
REPORT_WINDOW_TITLE = 'Results of normalization'
REPORT_HEADERS = [None]                  # <--- Define names of columns in the Report
REPORT_DEFAULT_X = 0                    # <--- INDEX IN REPORT_HEADERS USED TO SET NAME OF COLUMN THAT IS USED AS DEFAULT X IN THE REPORT
REPORT_DEFAULT_Y = 0                    # <--- INDEX IN REPORT_HEADERS USED TO SET NAME OF COLUMN THAT IS USED AS DEFAULT Y IN THE REPORT
REPORT_NAME = 'Results of normalization'
REPORT_NAME_X =  'Data Number'          # <--- NAME OF X AXIS IN THE REPORT
REPORT_NAME_Y =  'dY Value'             # <--- NAME OF Y AXIS IN THE REPORT
REPORT_UNIT_X = ''                      # <--- NAME OF X UNIT IN THE CREATED REPORT
REPORT_UNIT_Y = ''                      # <--- NAME OF Y UNIT IN THE CREATED REPORT
REPORT_TO_GROUP = 'RESULT Distance'     # <--- DEFAULT GROUP NAME TO WHICH REPORT WILL BE ADDED

# Cursors on graph
CURSOR_CHANGING = True                  # <--- IF TRUE THEN CURSOR SELECTION IN MAIN GUI WILL BE DISABLED
CURSOR_TYPE = 'None'                    # <--- USE CURSORS: 'None', 'Continuous read XY', 'Selection of points with labels'
                                        #       'Selection of points', 'Numbered selections', 'Free select', 'Crosshair', 'Range select'
CURSOR_LIMIT = 0                        # <--- SET THE MAXIMUM NUMBER OF CURSORS THAT CAN BE SELECTED. FOR NO LIMIT SET 0
CURSOR_CLEAR_ON_START = False
CURSOR_REQUIRED = 0                     # <--- MINIMUM NUMBER OF CURSORS TO PROCESS THE CALCULATIONS
                                        #      SET TO 0 FOR NO CHECKING
CURSOR_REQ_TEXT = \
    'Please select two points.'         # <--- TEXT TO DISPLAY IF NR OF CURSORS IS LESS THAN REQUIRED
                                        #    LEAVE EMPTY IF YOU DO NOT WANT TO SHOW THE ERROR
CURSOR_OUTSIDE_X = False                # <--- CHECK IF ALL CURSORS ARE BETWEEN Xmin Xmax FOR SELF>DATA_FOR_CALCULATIONS
CURSOR_OUTSIDE_Y = False
CURSOR_OUTSIDE_TEXT = \
                'One or more selected points are outside the (x, y) range of data.'
'''
##################################
#    END OF SUBPROG SETTINGS     #
#  DO NOT MODIFY LINES BELOW     #
##################################'''

cmd_to_import = GUI_FILE[:-3] + ' import ' + GUI_CLASS + ' as WindowGUI'                            #|
if __name__ == "__main__":                                                                          #|
    cmd_to_import = 'from ' + cmd_to_import                                                         #|
else:                                                                                               #|
    cmd_to_import = 'from ' + SUBPROG_FOLDER + '.' + cmd_to_import                                  #|
exec(cmd_to_import)                                                                                 #|
from subprogs.general_methods.SubprogMethods2 import SubMethods_02 as Methods                                                    #|
class Normalize(Methods, WindowGUI):                                                       #|
    def __init__(self, app=None, which='first', commandline=False):  # |
        if app and not commandline:
            # Initialize window if app is defined and not commandline                               #|
            WindowGUI.__init__(self, app.mainwindow)
        # Create settings for the subprog                                                           #|
        self.subprog_settings = {'title': TITLE, 'on_top': ON_TOP, 'data_label': DATA_LABEL,
                                 'name_suffix': NAME_SUFFIX, 'auto_calculate': AUTO_CALCULATE,
                                 'result': RESULT_CREATE}
        self.regions = {'from': REGIONS_FROM}
        self.report = {'nr': 1,
                       'create': REPORT_CREATE,
                       'headers': REPORT_HEADERS,
                       'rows': [],
                       'x_name': REPORT_NAME_X,
                       'y_name': REPORT_NAME_Y,
                       'default_x': REPORT_HEADERS[REPORT_DEFAULT_X],
                       'default_y': REPORT_HEADERS[REPORT_DEFAULT_Y],
                       'x_unit': REPORT_UNIT_X,
                       'y_unit': REPORT_UNIT_Y,
                       'to_group': REPORT_TO_GROUP,
                       'report_skip_for_stk':REPORT_SKIP_FOR_STK,
                       'report_window_title':REPORT_WINDOW_TITLE,
                       'report_name':REPORT_NAME
                       }
        self.subprog_cursor = {'type': CURSOR_TYPE, 'changing': CURSOR_CHANGING, 'limit': CURSOR_LIMIT,
                               'clear_on_start': CURSOR_CLEAR_ON_START, 'cursor_required': CURSOR_REQUIRED, 'cursor_req_text':CURSOR_REQ_TEXT,
                               'cursor_outside_x':CURSOR_OUTSIDE_X, 'cursor_outside_y':CURSOR_OUTSIDE_Y,
                               'cursor_outside_text':CURSOR_OUTSIDE_TEXT}
        # Use second data
        self.use_second = USE_SECOND
        # Treat each data in stack separately
        self.stack_sep = STACK_SEP  # |
        Methods.__init__(self, app=app, which=which, commandline=commandline)


    # PRE-DEFINED FUNCTIONS TO EXECUTE AT DIFFERENT STAGES OF SUBPROG METHODS
    # Unused definitions can be deleted

    def graph_action(self, variable=None, value=None):
        ''' Do something when cursor action on is triggered. '''

    def after_data_changed(self, variable, value):
        ''' This method is called after data changing by clicking in the Main GUI. '''

    def after_calculations(self):
        ''' This method is called after single calculations
            and just before showing the report. '''

    def after_result_show_on_graph(self):
        ''' This method is called immediately when results
            for graph are ready but grapher canva has not been refreshed yet. '''

    def after_ok_clicked(self):
        ''' This method is called when all functions are
            finished after clicking 'Calculate' button. '''

    def after_process_group_clicked(self):
        ''' This method is called when all functions are
             finished after clicking 'Process group' button. '''

    def after_graph_plot(self):
        ''' This method is called when the main application refreshes Graph canva content.
            For example, after changing First data, the graph is reploted and then
            this function is run. '''


    # DEFINE YOUR CUSTOM METHODS FOR THIS ROUTINE
    # ----------------------------------------------
    def configure_window(self):
        # HERE DEFINE ADDITIONAL MAIN WINDOW CONFIGURATION
        #self.mainwindow =

        # HERE DEFINE YOUR REFERENCES TO WIDGETS
        self.spinboxFrame = self.builder.get_object('spinboxFrame', self.mainwindow)
        self.spinbox = self.builder.get_object('spinbox', self.mainwindow)
        self.spinbox.grid_remove()
        self.spinbox = CTkSpinbox(master=self.spinboxFrame, wait_for=0.05, command=self.spinbox_value_changed, min_value=0,
                                  step_value=0.02, scroll_value=0.01, start_value=1)
        self.spinbox.grid(column=0, row=0, sticky='ew')
        self.normalize_to = float(self.spinbox.get())

    def spinbox_value_changed(self, value = None):
        self.normalize_to = float(self.spinbox.get())
        self.ok_clicked()

    def process_group(self):
        self.process_group_clicked()

    def calculate_stack(self, commandline = False):
        ''' If STACK_SEP is False it means that data in stack should
            not be treated as separate data but are calculated as whole

            DO NOT USE FUNCTION REQUIRED GUI UPDATE HERE
            '''
        # AVAILABLE DATA. REMOVE UNNECESSARY
        # EACH X,Y,Z IS NP.ARRAY
        # X, Z is 1D, Y is 2D
        # -----------------------------------------
        x1 = self.data_for_calculations[0]['x']
        y1 = self.data_for_calculations[0]['y']
        z1 = self.data_for_calculations[0]['z']
        name1 = self.data_for_calculations[0]['name']
        stk_value1 = self.data_for_calculations[0]['stk_value']
        complex1 = self.data_for_calculations[0]['complex']
        type1 = self.data_for_calculations[0]['type']
        origin1 = self.data_for_calculations[0]['origin']
        comment1 = self.data_for_calculations[0]['comment']
        parameters1 = self.data_for_calculations[0]['parameters']
        if self.use_second:
            x2 = self.data_for_calculations[1]['x']
            y2 = self.data_for_calculations[1]['y']
            z2 = self.data_for_calculations[1]['z']
            name2 = self.data_for_calculations[1]['name']
            stk_value2 = self.data_for_calculations[1]['stk_value']
            complex2 = self.data_for_calculations[1]['complex']
            type2 = self.data_for_calculations[1]['type']
            origin2 = self.data_for_calculations[1]['origin']
            comment2 = self.data_for_calculations[1]['comment']
            parameters2 = self.data_for_calculations[1]['parameters']
        # ------------------------------------------
        amplitudes = []
        for data in y1:
            amplitude = self.calc_amplitude(data)
            amplitudes.append(amplitude)
        amplitude = sorted(amplitudes, reverse=True)[0]

        list_of_processed_y = []
        for data in y1:
            single_y = data / amplitude * self.normalize_to
            single_y = np.array(single_y)
            list_of_processed_y.append(single_y)
            processed_y = np.array(list_of_processed_y)
        self.data_for_calculations[0]['y'] = processed_y

        # Send calculated values to result (if needed). This will be sent to command line
        result = None  # <--- HERE IS THE RESULT TO SEND TO COMMAND LINE

        # Create summary row to add to the report. The values must match the column names in REPORT_HEADERS
        row_to_report = None

        # Update Window Widgets
        return row_to_report

    def calculate(self, commandline = False):
        ''' The algorithm for calculations on single x,y,z data.

        Usage:
            x1, y1, z1: contain the prepared x, y, z data for calculations
            x2, y2, z2: contain the reference data to use for example to subtract from data1
        After calculation put calculated data to:
            x1, y1 and z1 etc.
            result: the value of resulted calculations

            DO NOT USE FUNCTION REQUIRED GUI UPDATE HERE
        '''

        # AVAILABLE DATA. REMOVE UNNECESSARYself.show_results_matching_first()
        # EACH X,Y,Z IS NP.ARRAY OF ONE DIMENSION
        # -----------------------------------------
        x1 = self.data_for_calculations[0]['x']
        y1 = self.data_for_calculations[0]['y']
        z1 = self.data_for_calculations[0]['z']
        name1 = self.data_for_calculations[0]['name']
        stk_value1 = self.data_for_calculations[0]['stk_value']
        complex1 = self.data_for_calculations[0]['complex']
        type1 = self.data_for_calculations[0]['type']
        origin1 = self.data_for_calculations[0]['origin']
        comment1 = self.data_for_calculations[0]['comment']
        parameters1 = self.data_for_calculations[0]['parameters']
        if self.use_second:
            x2 = self.data_for_calculations[1]['x']
            y2 = self.data_for_calculations[1]['y']
            z2 = self.data_for_calculations[1]['z']
            name2 = self.data_for_calculations[1]['name']
            stk_value2 = self.data_for_calculations[1]['stk_value']
            complex2 = self.data_for_calculations[1]['complex']
            type2 = self.data_for_calculations[1]['type']
            origin2 = self.data_for_calculations[1]['origin']
            comment2 = self.data_for_calculations[1]['comment']
            parameters2 = self.data_for_calculations[1]['parameters']
        cursor_positions = self.grapher.cursor_annotations
        # ------------------------------------------

        if complex1:
            y = np.abs(y1)
        min_ = np.min(y1)
        max_ = np.max(y1)
        amplitude = float(max_ - min_)
        normalized_y = y1 / amplitude * self.normalize_to
        self.data_for_calculations[0]['y'] = normalized_y

        # Send calculated values to result (if needed). This will be sent to command line
        result = None # <--- HERE IS THE RESULT TO SEND TO COMMAND LINE

        # Create summary row to add to the report. The values must match the column names in REPORT_HEADERS
        row_to_report = None

        # Update Window Widgets
        return row_to_report

    def calc_amplitude(self, y):
        ''' This is function that performs calculation
            on a single Y data (also for stack)
            You must define your calculations here
        '''
        if np.iscomplexobj(y):
            y = np.abs(y)
        min_ = np.min(y)
        max_ = np.max(y)
        amplitude = float(max_ - min_)
        return amplitude

if __name__ == "__main__":
    pass

