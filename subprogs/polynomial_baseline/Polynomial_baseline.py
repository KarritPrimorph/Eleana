#!/usr/bin/python3
# IMPORT MODULES NEEDED
# -- Here is an example --

from subprogs.integrate_region.IntegrateRegion import RESULT_CREATE

# General setting of the application. Here is an example
# File/Path/Class settings

SUBPROG_FOLDER = 'polynomial_baseline'        # <--- SUBFOLDER IN SUBPROGS CONTAINING THIS FILE
GUI_FILE = 'BaselinePolynomui.py'          # <--- PYTHON FILE GENERATED BY PYGUBU-DESIGNER CONTAINING GUI
GUI_CLASS = 'BaselinePolynomUI'            # <--- CLASS NAME IN GUI_FILE THAT BUILDS THE WINDOW

# Window settings
TITLE = 'Polynomial baseline subtraction'         # <--- TITLE OF THE WINDOW
ON_TOP = True                           # <--- IF TRUE THE WINDOW WILL BE ALWAYS ON TOP
DATA_LABEL = 'data_label'               # <--- ID OF THE LABEL WIDGET WHERE NAME OF CURRENTLY SELECTED DATA WILL APPEAR.
                                        #      THE LABEL WIDGET OF THE SAME ID NAME MUST EXIST IN THE GUI. IF NOT USED SET THIS TO NONE
NAME_SUFFIX = ''                        # <--- DEFINES THE SUFFIX THAT WILL BE ADDED TO NAME OF PROCESSED DATA
AUTO_CALCULATE = False                  # <--- DEFINES IF CALCULATION IS AUTOMATICALLY PERFORMED UPON DATA CHANGE IN GUI

# Data settings
#REGIONS_FROM = 'scale'                  # <--- DEFINES IF DATA WILL BE EXTRACTED:
REGIONS_FROM = 'selection'             # 'none' - DO NOT EXTRACT
                                        # 'scale' - EXTRACT DATA BETWEEN X MIN X MAX
                                        # 'sel' - EXTRACT DATA FROM SELECTED RANGE

USE_SECOND = False                      # <--- IF TRUE THEN FIRST AND SECOND DATA WILL BE AVAILABLE FOR CALCULATIONS
STACK_SEP = True                        # <--- IF TRUE THEN EACH DATA IN A STACK WILL BE CALCULATED SEPARATELY
                                        #      WHEN FALSE THEN YOU MUST CREATE A METHOD THAT CALCS OF THE WHOLE STACK
RESULT_CREATE = 'add'
#RESULT_CREATE = 'add'                  # <--- DETEMINES IF PROCESSED DATA SHOULD BE ADDED TO RESULT_DATASET
#RESULT_CREATE = 'replace'              #      'ADD' OR 'REPLACE' IS SELF EXPLANATORY
                                        #      ANY OTHER VALUES MEANS NOT RESULT CREATION

# Report settings
REPORT_CREATE = False                    # <--- IF TRUE THEN REPORT WILL BE CREATED AFTER CALCULATIONS
REPORT_HEADERS = []                     # <--- Define names of columns in the Report
REPORT_DEFAULT_X = 0                    # <--- INDEX IN REPORT_HEADERS USED TO SET NAME OF COLUMN THAT IS USED AS DEFAULT X IN THE REPORT
REPORT_DEFAULT_Y = 1                    # <--- INDEX IN REPORT_HEADERS USED TO SET NAME OF COLUMN THAT IS USED AS DEFAULT Y IN THE REPORT
REPORT_NAME_X =  ''                     # <--- NAME OF X AXIS IN THE REPORT
REPORT_NAME_Y =  ''                     # <--- NAME OF Y AXIS IN THE REPORT
REPORT_UNIT_X = ''                      # <--- NAME OF X UNIT IN THE CREATED REPORT
REPORT_UNIT_Y = ''                      # <--- NAME OF Y UNIT IN THE CREATED REPORT
REPORT_TO_GROUP = ''                    # <--- DEFAULT GROUP NAME TO WHICH REPORT WILL BE ADDED

# Cursors on graph
CURSOR_CHANGING = False                  # <--- IF TRUE THEN CURSOR SELECTION IN MAIN GUI WILL BE DISABLED
CURSOR_TYPE = 'Range select'               # <--- USE CURSORS: 'None', 'Continuous read XY', 'Selection of points with labels'
                                        #       'Selection of points', 'Numbered selections', 'Free select', 'Crosshair', 'Range select'
CURSOR_LIMIT = 0                        # <--- SET THE MAXIMUM NUMBER OF CURSORS THAT CAN BE SELECTED. FOR NO LIMIT SET 0
CURSOR_CLEAR_ON_START = True
CURSOR_REQUIRED = 0                     # <--- MINIMUM NUMBER OF CURSORS TO PROCESS THE CALCULATIONS
                                        #      SET TO 0 FOR NO CHECKING
CURSOR_REQ_TEXT = \
    'Please select two points.'         # <--- TEXT TO DISPLAY IF NR OF CURSORS IS LESS THAN REQUIRED
                                        #    LEAVE EMPTY IF YOU DO NOT WANT TO SHOW THE ERROR
CURSOR_OUTSIDE_X = False                # <--- CHECK IF ALL CURSORS ARE BETWEEN Xmin Xmax FOR SELF>DATA_FOR_CALCULATIONS
CURSOR_OUTSIDE_Y = False
CURSOR_OUTSIDE_TEXT = \
                'One or more selected points are outside the (x, y) range of data.'
'''
##################################
#    END OF SUBPROG SETTINGS     #
#  DO NOT MODIFY LINES BELOW     #
##################################'''

cmd_to_import = GUI_FILE[:-3] + ' import ' + GUI_CLASS + ' as WindowGUI'                            #|
if __name__ == "__main__":                                                                          #|
    cmd_to_import = 'from ' + cmd_to_import                                                         #|
else:                                                                                               #|
    cmd_to_import = 'from ' + SUBPROG_FOLDER + '.' + cmd_to_import                                  #|
exec(cmd_to_import)                                                                                 #|
from subprogs.general_methods.SubprogMethods2 import SubMethods_02 as Methods                                                    #|
class PolynomialBaseline(Methods, WindowGUI):                                                       #|
    def __init__(self, app=None, which='first', commandline=False):  # |
        if app and not commandline:
            # Initialize window if app is defined and not commandline                               #|
            WindowGUI.__init__(self, app.mainwindow)
        # Create settings for the subprog                                                           #|
        self.subprog_settings = {'title': TITLE, 'on_top': ON_TOP, 'data_label': DATA_LABEL,
                                 'name_suffix': NAME_SUFFIX, 'auto_calculate': AUTO_CALCULATE,
                                 'result': RESULT_CREATE}
        self.regions = {'from': REGIONS_FROM}
        self.report = {'nr': 1,
                       'create': REPORT_CREATE,
                       'headers': REPORT_HEADERS,
                       'rows': [],
                       'x_name': REPORT_NAME_X,
                       'y_name': REPORT_NAME_Y,
                       'default_x': REPORT_HEADERS[REPORT_DEFAULT_X],
                       'default_y': REPORT_HEADERS[REPORT_DEFAULT_Y],
                       'x_unit': REPORT_UNIT_X,
                       'y_unit': REPORT_UNIT_Y,
                       'to_group': REPORT_TO_GROUP
                       }
        self.subprog_cursor = {'type': CURSOR_TYPE, 'changing': CURSOR_CHANGING, 'limit': CURSOR_LIMIT,
                               'clear_on_start': CURSOR_CLEAR_ON_START, 'cursor_required': CURSOR_REQUIRED, 'cursor_req_text':CURSOR_REQ_TEXT,
                               'cursor_outside_x':CURSOR_OUTSIDE_X, 'cursor_outside_y':CURSOR_OUTSIDE_Y,
                               'cursor_outside_text':CURSOR_OUTSIDE_TEXT}
        # Use second data
        self.use_second = USE_SECOND
        # Treat each data in stack separately
        self.stack_sep = STACK_SEP  # |
        Methods.__init__(self, app=app, which=which, commandline=commandline)

    # PRE-DEFINED FUNCTIONS TO EXECUTE AT DIFFERENT STAGES OF SUBPROG METHODS
    # Unused definitions can be deleted

    def graph_action(self, variable=None, value=None):
        ''' Do something when cursor action on is triggered. '''

    def after_data_changed(self, variable, value):
        ''' This method is called after data changing by clicking in the Main GUI. '''

    def after_calculations(self):
        ''' This method is called after single calculations
            and just before showing the report. '''

    def after_result_show_on_graph(self):
        ''' This method is called immediately when results
            for graph are ready but grapher canva has not been refreshed yet. '''

    def after_ok_clicked(self):
        ''' This method is called when all functions are
            finished after clicking 'Calculate' button. '''

    def after_process_group_clicked(self):
        ''' This method is called when all functions are
             finished after clicking 'Process group' button. '''

    def after_graph_plot(self):
        ''' This method is called when the main application refreshes Graph canva content.
            For example, after changing First data, the graph is reploted and then
            this function is run. '''


    # DEFINE YOUR CUSTOM METHODS FOR THIS ROUTINE
    # ----------------------------------------------
    def configure_window(self):
        # HERE DEFINE ADDITIONAL MAIN WINDOW CONFIGURATION
        #self.mainwindow =

        # HERE DEFINE YOUR REFERENCES TO WIDGETS
        self.sel_polynomial = self.builder.get_object('sel_polynomial', self.mainwindow)
        self.keep_baseline = self.builder.get_object('keep_baseline', self.mainwindow)

        self.keep_baseline.deselect()
        self.sel_polynomial.set(value="Linear")

    @Methods.skip_if_empty_graph
    def keep_current_baseline(self):
        print("Keep current baseline")

    def sel_polynomial_clicked(self, value):
        print(value)

    def calculate_stack(self, commandline = False):
        ''' If STACK_SEP is False it means that data in stack should
            not be treated as separate data but are calculated as whole

            DO NOT USE FUNCTION REQUIRED GUI UPDATE HERE
            '''
        # AVAILABLE DATA. REMOVE UNNECESSARY
        # EACH X,Y,Z IS NP.ARRAY
        # X, Z is 1D, Y is 2D
        # -----------------------------------------
        x1 = self.data_for_calculations[0]['x']
        y1 = self.data_for_calculations[0]['y']
        z1 = self.data_for_calculations[0]['z']
        name1 = self.data_for_calculations[0]['name']
        stk_value1 = self.data_for_calculations[0]['stk_value']
        complex1 = self.data_for_calculations[0]['complex']
        type1 = self.data_for_calculations[0]['type']
        origin1 = self.data_for_calculations[0]['origin']
        comment1 = self.data_for_calculations[0]['comment']
        parameters1 = self.data_for_calculations[0]['parameters']
        if self.use_second:
            x2 = self.data_for_calculations[1]['x']
            y2 = self.data_for_calculations[1]['y']
            z2 = self.data_for_calculations[1]['z']
            name2 = self.data_for_calculations[1]['name']
            stk_value2 = self.data_for_calculations[1]['stk_value']
            complex2 = self.data_for_calculations[1]['complex']
            type2 = self.data_for_calculations[1]['type']
            origin2 = self.data_for_calculations[1]['origin']
            comment2 = self.data_for_calculations[1]['comment']
            parameters2 = self.data_for_calculations[1]['parameters']
        # ------------------------------------------

    def calculate(self, commandline = False):
        ''' The algorithm for calculations on single x,y,z data.

        Usage:
            x1, y1, z1: contain the prepared x, y, z data for calculations
            x2, y2, z2: contain the reference data to use for example to subtract from data1
        After calculation put calculated data to:
            x1, y1 and z1 etc.
            result: the value of resulted calculations

            DO NOT USE FUNCTION REQUIRED GUI UPDATE HERE
        '''

        # AVAILABLE DATA. REMOVE UNNECESSARY
        # EACH X,Y,Z IS NP.ARRAY OF ONE DIMENSION
        # -----------------------------------------
        x1 = self.data_for_calculations[0]['x']
        y1 = self.data_for_calculations[0]['y']
        z1 = self.data_for_calculations[0]['z']
        name1 = self.data_for_calculations[0]['name']
        stk_value1 = self.data_for_calculations[0]['stk_value']
        complex1 = self.data_for_calculations[0]['complex']
        type1 = self.data_for_calculations[0]['type']
        origin1 = self.data_for_calculations[0]['origin']
        comment1 = self.data_for_calculations[0]['comment']
        parameters1 = self.data_for_calculations[0]['parameters']
        if self.use_second:
            x2 = self.data_for_calculations[1]['x']
            y2 = self.data_for_calculations[1]['y']
            z2 = self.data_for_calculations[1]['z']
            name2 = self.data_for_calculations[1]['name']
            stk_value2 = self.data_for_calculations[1]['stk_value']
            complex2 = self.data_for_calculations[1]['complex']
            type2 = self.data_for_calculations[1]['type']
            origin2 = self.data_for_calculations[1]['origin']
            comment2 = self.data_for_calculations[1]['comment']
            parameters2 = self.data_for_calculations[1]['parameters']
        cursor_positions = self.grapher.cursor_annotations
        # ------------------------------------------

        self.temporary_plots = [{
                                'x' : x1,
                                'y' : y2,
                                'legend': 'tekst',
                                'color': 'gray',
                                'linewidth': 2,
                                'linestyle': 'dashed',

                                }]



        # Send calculated values to result (if needed). This will be sent to command line
        result = [0, 0] # <--- HERE IS THE RESULT TO SEND TO COMMAND LINE

        # Create summary row to add to the report. The values must match the column names in REPORT_HEADERS
        row_to_report = [self.consecutive_number, name1, x1val, x2val, dx, y1val, y2val, dy]

        # Update Window Widgets
        if self.app and not self.commandline:                                                                           #|
            # Put values to the entries
            self.set_entry_value(self.x1_entry, x1val)
            self.set_entry_value(self.x2_entry, x2val)
            self.set_entry_value(self.y1_entry, y1val)
            self.set_entry_value(self.y2_entry, y2val)
            self.set_entry_value(self.dx_entry, dx)
            self.set_entry_value(self.dy_entry, dy)
        return row_to_report

if __name__ == "__main__":

    pass

